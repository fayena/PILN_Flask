<div class="chart-toolbar" style="display:flex;gap:10px;align-items:center;margin:8px 0;">
  <button id="resetZoom" class="piln-btn">Reset zoom</button>
  <small style="opacity:.8">Tip: Ctrl + mouse wheel to zoom, drag to pan</small>
</div>

<div class="chart-wrap">
  <canvas id="myChart"></canvas>
</div>

<script src="../style/js/chart.min.js"></script>
<script src="../style/js/chartjs-plugin-zoom.min.js"></script>
<script>
let myChart, lastIso = null;
const run_id = "{{ run_id }}";
const POLL_MS = 30000, MAX_POINTS = 5000;

async function fetchDelta(since = null) {
  const res = await fetch('/api/data', {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify({ run_id, since })
  });
  if (!res.ok) throw new Error('fetch failed');
  return res.json();
}

function buildChart(d) {
  const ctx = document.getElementById('myChart').getContext('2d');
  myChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: d.dt_label,
      datasets: [
        { label: 'Temperature',         yAxisID:'y1', fill:false, borderColor:'#e07a14', data:d.temp,        pointRadius:0 },
        { label: 'Target Temperature',  yAxisID:'y1', fill:false, borderColor:'#c82a2a', data:d.set_temp,    pointRadius:0 },
        { label: 'PID Output',          yAxisID:'y1', type:'bar', borderColor:'#37883a', backgroundColor:'#37883a', data:d.pid_output },
        { label: 'Segment',             yAxisID:'y2', fill:false, borderColor:'#2a4fc8', data:d.segment,     pointRadius:0 }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false, // use .chart-wrap height
      animation: { duration: 0 },
      interaction: { mode: 'nearest', intersect: false },
      scales: {
        x: { type: 'category' },
        y1: { type:'linear', position:'left',  title:{ display:true, text:'Temperature' } },
        y2: { type:'linear', position:'right', grid:{ drawOnChartArea:false }, ticks:{ stepSize:1 }, title:{ display:true, text:'Segments' } }
      },
      plugins: {
        legend: { display: true },
        zoom: {
          limits: { x: { min: 'original', max: 'original' }, y: { min: 'original', max: 'original' } },
          pan:  { enabled: true, mode: 'x' },
          zoom: {
            wheel:  { enabled: true, modifierKey: 'ctrl' }, // Ctrl+wheel to zoom
            pinch:  { enabled: true },                      // mobile pinch
            mode: 'x'
          }
        }
      }
    }
  });

  // Reset zoom button + double-click reset
  document.getElementById('resetZoom').addEventListener('click', () => myChart.resetZoom());
  document.getElementById('myChart').addEventListener('dblclick', () => myChart.resetZoom());
}

function appendDelta(d) {
  if (!d || !d.dt_label || d.dt_label.length === 0) return;

  myChart.data.labels.push(...d.dt_label);
  myChart.data.datasets[0].data.push(...d.temp);
  myChart.data.datasets[1].data.push(...d.set_temp);
  myChart.data.datasets[2].data.push(...d.pid_output);
  myChart.data.datasets[3].data.push(...d.segment);

  if (myChart.data.labels.length > MAX_POINTS) {
    const cut = myChart.data.labels.length - MAX_POINTS;
    myChart.data.labels.splice(0, cut);
    for (const ds of myChart.data.datasets) ds.data.splice(0, cut);
  }
  myChart.update('none'); // keep zoom/pan state
}

(async function init(){
  const initial = await fetchDelta(null);
  buildChart(initial);
  lastIso = initial.last_iso || null;

  setInterval(async () => {
    try {
      const d = await fetchDelta(lastIso);
      appendDelta(d);
      if (d.last_iso) lastIso = d.last_iso;
    } catch (e) {
      console.error(e);
    }
  }, POLL_MS);
})();
</script>
